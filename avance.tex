\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{graphicx}
\usepackage{array}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[normalem]{ulem}   % para \uline (subrayado que respeta saltos)
\usepackage[T1]{fontenc}      % buen copy/paste de subrayados
\usepackage{lmodern}          % tipo de letra moderna
% --- Macros de estilo ---
\newcommand{\relname}[1]{\textcolor{green!60!black}{#1}}
\newcommand{\attr}[1]{\textcolor{blue!70!black}{#1}}
\newcommand{\rel}[1]{\textbf{\textcolor{green!70!black}{#1}}}
\newcommand{\pk}[1]{\uline{\textcolor{green!60!black}{#1}}}
\newcommand{\fk}[2]{\uline{\relname{#1}.\attr{#2}}}
\usepackage[export]{adjustbox}

\begin{document}


% Portada
\begin{center}
    \includegraphics[width=0.9\textwidth]{UtecLogo.jpeg} \\
    \vspace{1cm}
    \normalsize \textbf{Fredys Food} \\
    \vspace{1cm}
    \textbf{Hito 1 Proyecto DB} \\
    \vspace{0.5cm}
    \textbf{Curso:} \\
    \textbf{Base de Datos I} \\
    \vspace{0.5cm}
    \textbf{Profesor:} \\
    \textbf{Brenner Ojeda, Wilder Nina} \\
    \vspace{0.5cm}
    \textbf{Estudiantes:}
\end{center}

\vspace{0.5cm}

\begin{table}[h]
    \centering
    \begin{tabular}{|>{\raggedright\arraybackslash}m{6cm}|m{3cm}|}
    \hline
    \textbf{Integrantes} & \textbf{Códigos} \\ \hline
    Jossue Guillermo Caceres Molina & 202410768 \\ \hline
    Diana Sofia Rosales Bazán & 202410535 \\ \hline
    Esteban Jose Sulca Infante & 202210342 \\ \hline
    \end{tabular}
\end{table}

\vfill
\begin{center}
    Lima -- Perú \\
    Mayo, 2025
\end{center}

\newpage

% Contenido
\tableofcontents
\newpage

%---------------------------------------------------
\section{Requisitos}
\subsection{Introducción}
El presente proyecto tiene como objetivo desarrollar una base de datos integral para la gestión de un sistema de delivery de menús diarios orientado a trabajadores corporativos. Este sistema, denominado "Fredys Food", busca optimizar la experiencia de pedidos de comida para empleados de diversas empresas, facilitando la administración de menús, pedidos, entregas y retroalimentación de clientes.

\subsection{Descripción general del problema/organización/empresa}
Fredys Food es un restaurante especializado en la preparación y entrega de menús ejecutivos dirigidos principalmente a trabajadores de oficinas y empresas en diferentes zonas de la ciudad. La organización enfrenta desafíos en la gestión manual de pedidos, coordinación de entregas por zonas, seguimiento de preferencias de clientes y análisis de satisfacción del servicio.

Actualmente, la empresa maneja aproximadamente 300 pedidos diarios distribuidos en múltiples zonas de entrega, con un equipo de repartidores especializados por área geográfica y administradores encargados de la creación de menús diarios.

\subsection{Necesidad/usos de la base de datos}
La base de datos es fundamental para:
\begin{itemize}
    \item Centralizar la gestión de usuarios (clientes, repartidores, administradores)
    \item Optimizar la creación y asignación de menús diarios
    \item Coordinar eficientemente las entregas por zonas geográficas
    \item Registrar y analizar la satisfacción del cliente mediante calificaciones
    \item Generar reportes de rendimiento operacional y financiero
    \item Facilitar la toma de decisiones basada en datos históricos
\end{itemize}

\subsection{¿Cómo resuelve el problema hoy?}
\subsubsection{¿Cómo se almacenan/procesan los datos hoy?}
Actualmente, la empresa utiliza un sistema híbrido poco eficiente:
\begin{itemize}
    \item Hojas de cálculo de Excel para registro de clientes y pedidos diarios
    \item Comunicación vía WhatsApp para coordinación con repartidores
    \item Cuadernos físicos para registrar menús y recetas
    \item Archivos PDF para almacenar información nutricional de platos
    \item Sistema manual de calificaciones mediante llamadas telefónicas
\end{itemize}

\subsubsection{Flujo de datos}
El flujo actual es fragmentado y propenso a errores:
1. Los administradores crean menús diarios en hojas de cálculo
2. Los clientes realizan pedidos vía telefónica o WhatsApp
3. Los pedidos se registran manualmente en Excel
4. Los repartidores reciben asignaciones vía mensajes de texto
5. La retroalimentación se recopila de forma inconsistente

\subsection{Descripción detallada del sistema}
\subsubsection{Objetos de información actuales}
\begin{itemize}
    \item \textbf{Usuarios}: Información personal de clientes y empleados
    \item \textbf{Platos}: Catálogo de comidas con especificaciones nutricionales
    \item \textbf{Menús}: Combinaciones diarias de platos disponibles
    \item \textbf{Pedidos}: Solicitudes de clientes con detalles temporales y geográficos
    \item \textbf{Zonas de entrega}: Áreas geográficas con costos diferenciados
    \item \textbf{Calificaciones}: Evaluaciones de satisfacción del cliente
\end{itemize}

\subsubsection{Características y funcionalidades esperadas}
\begin{itemize}
    \item Registro y autenticación de usuarios por roles
    \item Creación dinámica de menús por parte de administradores
    \item Sistema de pedidos en línea con seguimiento en tiempo real
    \item Asignación automática de repartidores por zona de cobertura
    \item Módulo de calificaciones y comentarios post-entrega
    \item Reportes automatizados de rendimiento y análisis de tendencias
    \item Gestión de inventario y disponibilidad de platos
\end{itemize}

\subsubsection{Tipos de usuarios existentes/necesarios}
\begin{itemize}
    \item \textbf{Clientes}: Empleados corporativos que realizan pedidos
    \item \textbf{Administradores}: Personal encargado de crear menús y gestionar el sistema
    \item \textbf{Repartidores}: Personal de entrega asignado por zonas geográficas
    \item \textbf{Supervisores}: Usuarios con acceso a reportes y análisis del sistema
\end{itemize}

\subsubsection{Tipos de consulta, actualizaciones}
\textbf{Consultas frecuentes}:
\begin{itemize}
    \item Menús disponibles para fecha específica
    \item Historial de pedidos por cliente
    \item Platos más populares por período
    \item Rendimiento de repartidores por zona
\end{itemize}

\textbf{Actualizaciones regulares}:
\begin{itemize}
    \item Creación diaria de menús
    \item Registro continuo de pedidos
    \item Actualización de estados de entrega
    \item Ingreso de calificaciones post-servicio
\end{itemize}

\subsubsection{Tamaño estimado de la base de datos}
\begin{itemize}
    \item Usuarios: 10,000 registros
    \item Platos: 200 registros activos
    \item Menús: 365 registros anuales
    \item Pedidos: 100,000 registros anuales
    \item Calificaciones: 60,000 registros anuales
\end{itemize}

\subsection{Objetivos del proyecto}
\begin{itemize}
    \item Desarrollar una base de datos normalizada y eficiente
    \item Implementar un sistema de consultas optimizado
    \item Crear índices estratégicos para mejorar el rendimiento
    \item Establecer integridad referencial y restricciones semánticas
    \item Facilitar la escalabilidad del sistema para crecimiento futuro
\end{itemize}

\subsection{Referencias del proyecto}
\begin{itemize}
    \item Documentación oficial de PostgreSQL 15.x
    \item Principios de diseño de bases de datos relacionales
    \item Mejores prácticas en sistemas de delivery y e-commerce
    \item Estándares de optimización de consultas SQL
\end{itemize}

\subsection{Eventualidades}
\subsubsection{Problemas que pudieran encontrarse en el proyecto}
\begin{itemize}
    \item Complejidad en la migración de datos existentes desde Excel
    \item Resistencia al cambio por parte de usuarios acostumbrados al sistema manual
    \item Posibles inconsistencias en datos históricos
    \item Necesidad de capacitación técnica para administradores del sistema
    \item Requerimientos de hardware para manejar volúmenes de datos crecientes
\end{itemize}

\subsubsection{Límites y alcances del proyecto}
\textbf{Alcances}:
\begin{itemize}
    \item Gestión completa de usuarios, menús, pedidos y entregas
    \item Sistema de calificaciones y retroalimentación
    \item Reportes básicos de rendimiento operacional
    \item Optimización para hasta 1 millón de registros
\end{itemize}

\textbf{Límites}:
\begin{itemize}
    \item No incluye integración con sistemas de pago en línea
    \item No contempla módulo de inventario de ingredientes
    \item No incluye sistema de notificaciones push
    \item Limitado a operaciones dentro del área metropolitana
\end{itemize}


\section{Modelo Entidad-Relación}
\subsection{Reglas semánticas}
El modelo entidad-relación propuesto captura las reglas clave del dominio del sistema de pedidos de menús para trabajadores:

\begin{itemize}
    \item Todo \textbf{usuario} pertenece exclusivamente a uno de los dos subtipos: \textbf{cliente} o \textbf{trabajador}.
    \item Un \textbf{trabajador} puede asumir uno de dos roles específicos: \textbf{administrador} o \textbf{repartidor}, pero no ambos a la vez.
    \item Cada \textbf{cliente} debe estar asignado a una única \textbf{zona de entrega}, la cual determina su cobertura y el costo del servicio.
    \item Una \textbf{zona de entrega} puede estar cubierta por uno o varios \textbf{repartidores}.
    \item Un \textbf{pedido} es realizado por un cliente, se origina en una zona de entrega y debe estar asociado a un menú disponible ese día.
    \item Cada \textbf{pedido} debe ser entregado por un único \textbf{repartidor}.
    \item Opcionalmente, un pedido puede incluir una \textbf{calificación} y un \textbf{comentario}, los cuales solo pueden ser registrados después de la entrega.
    \item Un \textbf{menú} debe ser creado por un único \textbf{administrador} y puede contener múltiples \textbf{platos}; un mismo plato puede estar presente en varios menús (relación N:M).
    \item Las \textbf{zonas de entrega} tienen un \textbf{nombre único} como clave y un \textbf{costo} fijo asociado.
    \item No se puede eliminar un \textbf{menú} ni un \textbf{plato} si ya está vinculado a algún \textbf{pedido}.
    \item Cada \textbf{plato} puede tener atributos complementarios como tipo, categoría, imagen y descripción nutricional.
    \item Los \textbf{pedidos} registran datos de trazabilidad: fecha, hora de salida, hora estimada y hora real de entrega.
\end{itemize}

\subsection{Modelo Entidad-Relación}
\begin{figure}[ht]
  \centering
  \includegraphics[max width=\textwidth]{ER-BD1.png}
  \caption{Diagrama Entidad-Relación del Sistema Fredys Food}
\end{figure}

\subsection{Especificaciones y consideraciones sobre el modelo}
El modelo entidad-relación se diseñó priorizando la claridad conceptual, integridad referencial y eficiencia para operaciones frecuentes del sistema de delivery. 

Las principales consideraciones incluyen:
\begin{itemize}
    \item \textbf{Jerarquía de especialización}: Se implementó herencia entre Usuario → Cliente/Trabajador → Administrador/Repartidor
    \item \textbf{Relaciones N:M}: Se modelaron explícitamente las relaciones Menú-Plato y Zona-Repartidor
    \item \textbf{Atributos temporales}: Los pedidos incluyen timestamps completos para trazabilidad operacional
    \item \textbf{Restricciones semánticas}: Se definieron reglas de negocio para mantener consistencia de datos
    \item \textbf{Escalabilidad}: El modelo soporta crecimiento proyectado sin reestructuración mayor
\end{itemize}

\section{Modelo Relacional}

\subsection{Modelo Relacional}
El modelo relacional está definido por las siguientes tablas  
(llaves primarias \pk{\,subrayadas\,}, llaves foráneas \fk{Tabla}{columna}):

\begin{itemize}\setlength\itemsep{0.3em}
  \item \rel{Usuario}(
    \pk{id\_usuario.Integer}, 
    nombre.String(50), 
    apellido.String(50), 
    numero\_telef.String(20)
  )
  \item \rel{Cliente}(
    \fk{Usuario}{id\_usuario}, 
    empresa.String(100)
  )
  \item \rel{Trabajador}(
    \fk{Usuario}{id\_usuario}, 
    telefono\_emergencia.String(20)
  )
  \item \rel{Repartidor}(
    \fk{Trabajador}{id\_usuario}
  )
  \item \rel{Administrador}(
    \fk{Trabajador}{id\_usuario}, 
    correo.String(100)
  )
  \item \rel{Menu}(
    \pk{id\_menu.Integer}, 
    \fk{Administrador}{id\_usuario}, 
    variacion.String(50), 
    fecha.Date
  )
  \item \rel{Plato}(
    \pk{id\_plato.Integer}, 
    nombre.String(100), 
    foto.String(255), 
    tipo.String(30), 
    categoria.String(30), 
    precio.Decimal(10,2),
    codigo\_info\_nutricional.String(255)
  )
  \item \rel{Pertenece}(
    \fk{Menu}{id\_menu}, 
    \fk{Plato}{id\_plato}
  )
  \item \rel{Pedido}(
    \pk{id\_pedido.Integer}, 
    fecha.DateTime, 
    estado.String(20), 
    hora\_salida.Time, 
    hora\_entrega.Time, 
    hora\_entrega\_estimada.Time, 
    direccion\_exacta.String(255), 
    \fk{ZonaEntrega}{nombre},
    \fk{Cliente}{id\_cliente}
  )
  \item \rel{Tiene}(
    \fk{Pedido}{id\_pedido}, 
    \fk{Menu}{id\_menu}
  )
  \item \rel{Hace}(
    \fk{Pedido}{id\_pedido}, 
    \fk{Usuario}{id\_usuario}, 
    calificacion.Integer, 
    comentario.String(255)
  )
  \item \rel{ZonaEntrega}(
    \pk{nombre.String(50)}, 
    costo.Decimal(10,2)
  )
  \item \rel{Vive}(
    \fk{ZonaEntrega}{nombre}, 
    \fk{Usuario}{id\_usuario}
  )
  \item \rel{Cubre}(
    \fk{ZonaEntrega}{nombre}, 
    \fk{Repartidor}{id\_usuario}
  )
\end{itemize}

\subsection{Especificaciones de transformación}
Las entidades y relaciones del modelo entidad-relación han sido transformadas en tablas relacionales, garantizando la normalización (hasta Tercera Forma Normal) y la integridad referencial mediante el uso de llaves primarias y foráneas.

\subsubsection{Entidades}
Las principales entidades se reflejan en tablas con sus atributos y llaves primarias correspondientes:
\begin{itemize}
    \item \textbf{Usuario}: Entidad base con identificador único, datos personales básicos
    \item \textbf{Cliente}: Especialización de Usuario con información empresarial
    \item \textbf{Trabajador}: Especialización de Usuario con datos laborales
    \item \textbf{Repartidor}: Especialización de Trabajador para personal de entrega
    \item \textbf{Administrador}: Especialización de Trabajador con permisos administrativos
    \item \textbf{Menu}: Entidad independiente con referencia al administrador creador
    \item \textbf{Plato}: Entidad independiente con información nutricional y comercial
    \item \textbf{Pedido}: Entidad central con información temporal y logística
    \item \textbf{ZonaEntrega}: Entidad independiente con información geográfica y costos
\end{itemize}

\subsubsection{Entidades débiles}
No se identifican entidades débiles en este modelo relacional, ya que todas las tablas principales disponen de un identificador único como llave primaria. Las tablas de relación (Pertenece, Tiene, Hace, Vive, Cubre) utilizan llaves compuestas formadas por las llaves foráneas de las entidades relacionadas.

\subsubsection{Entidades superclase/subclases}
El modelo implementa dos jerarquías de especialización:

\textbf{Primera jerarquía - Usuario:}
\begin{itemize}
    \item \textbf{Usuario} (Superclase): Contiene atributos comunes (id, nombre, apellido, teléfono)
    \item \textbf{Cliente} (Subclase): Añade atributo empresa
    \item \textbf{Trabajador} (Subclase): Añade teléfono de emergencia
\end{itemize}

\textbf{Segunda jerarquía - Trabajador:}
\begin{itemize}
    \item \textbf{Trabajador} (Superclase): Especialización de Usuario
    \item \textbf{Repartidor} (Subclase): Sin atributos adicionales, solo rol funcional
    \item \textbf{Administrador} (Subclase): Añade correo electrónico institucional
\end{itemize}

\textbf{Características de la especialización:}
- Cobertura total: Todo Usuario es Cliente o Trabajador
- Disyunción: Un Usuario no puede ser Cliente y Trabajador simultáneamente
- Un Trabajador puede ser Repartidor o Administrador, pero no ambos

\subsubsection{Relaciones binarias}
Las relaciones binarias se implementan mediante tablas de unión que vinculan las llaves primarias de las tablas participantes:

\begin{itemize}
    \item \textbf{Pertenece} (Menu ↔ Plato): Relación N:M que permite que un menú contenga múltiples platos y un plato esté en varios menús
    \item \textbf{Tiene} (Pedido ↔ Menu): Relación N:M que asocia pedidos con los menús solicitados
    \item \textbf{Hace} (Usuario ↔ Pedido): Relación 1:N con atributos (calificación, comentario) que registra qué cliente realiza cada pedido
    \item \textbf{Vive} (Usuario ↔ ZonaEntrega): Relación N:1 que indica la zona de residencia del cliente
    \item \textbf{Cubre} (Repartidor ↔ ZonaEntrega): Relación N:M que define qué repartidores atienden cada zona
    \item \textbf{Crea} (Administrador ↔ Menu): Relación 1:N implícita en la llave foránea de Menu
    \item \textbf{Entrega} (Repartidor ↔ Pedido): Relación 1:N implícita mediante zona de cobertura
\end{itemize}

\subsubsection{Relaciones ternarias}
No se identifican relaciones ternarias en este modelo relacional. Todas las asociaciones complejas se resuelven mediante combinaciones de relaciones binarias o se implementan como atributos en las tablas principales, manteniendo la simplicidad y eficiencia del diseño.

\subsection{Diccionario de datos}

El diccionario de datos describe cada atributo de las tablas en el modelo relacional, asegurando que todos los usuarios del sistema comprendan el significado, el tipo de datos y las restricciones de cada atributo en las tablas.

\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}      & \textbf{Tipo de dato} & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Usuario}} \\
\hline
id\_usuario                & BIGSERIAL             & X           &             & Identificador único autoincremental del usuario. \\
nombre                     & VARCHAR(50)           &             &             & Nombre propio del usuario. \\
apellido                   & VARCHAR(50)           &             &             & Apellido del usuario. \\
numero\_telef              & VARCHAR(20)           &             &             & Número de teléfono (incluye código de país). \\
\hline
\end{tabular}
\caption{Usuario}
\label{table:usuario}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}      & \textbf{Tipo de dato} & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Cliente}} \\
\hline
id\_usuario                & BIGINT                & X           & X           & Clave primaria y foránea que referencia a \texttt{Usuario.id\_usuario}. \\
empresa                    & VARCHAR(100)          &             &             & Razón social de la empresa cliente. \\
\hline
\end{tabular}
\caption{Cliente}
\label{table:cliente}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}      & \textbf{Tipo de dato} & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Trabajador}} \\
\hline
id\_usuario                & BIGINT                & X           & X           & Clave primaria y foránea que referencia a \texttt{Usuario.id\_usuario}. \\
telefono\_emergencia       & VARCHAR(20)           &             &             & Teléfono de emergencia del trabajador. \\
\hline
\end{tabular}
\caption{Trabajador}
\label{table:trabajador}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}      & \textbf{Tipo de dato} & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Repartidor}} \\
\hline
id\_usuario                & BIGINT                & X           & X           & Clave primaria y foránea que referencia a \texttt{Trabajador.id\_usuario}. \\
\hline
\end{tabular}
\caption{Repartidor}
\label{table:repartidor}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}      & \textbf{Tipo de dato} & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Administrador}} \\
\hline
id\_usuario                & BIGINT                & X           & X           & Clave primaria y foránea que referencia a \texttt{Trabajador.id\_usuario}. \\
correo                     & VARCHAR(100)          &             &             & Correo electrónico institucional. \\
\hline
\end{tabular}
\caption{Administrador}
\label{table:administrador}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}                       & \textbf{Tipo de dato}   & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Menu}} \\
\hline
id\_menu                                     & BIGSERIAL               & X           &             & Identificador único autoincremental del menú. \\
id\_administrador                            & BIGINT                  &             & X           & Clave foránea que referencia a \texttt{Administrador.id\_usuario}. \\
variacion                                   & VARCHAR(50)             &             &             & Versión o tipo de menú. \\
fecha                                       & DATE                    &             &             & Fecha de vigencia del menú. \\
\hline
\end{tabular}
\caption{Menu}
\label{table:menu}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}      & \textbf{Tipo de dato} & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Plato}} \\
\hline
id\_plato                  & SERIAL                & X           &             & Identificador único autoincremental del plato. \\
nombre                     & VARCHAR(100)          &             &             & Nombre comercial del plato. \\
foto                       & TEXT                  &             &             & Ruta o URL de la imagen. \\
tipo                       & VARCHAR(30)           &             &             & Categoria (entrada, principal, postre, bebida). \\
categoria                  & VARCHAR(30)           &             &             & Subcategoria alimenticia (vegano, sin gluten, etc.). \\
precio                     & DECIMAL(10,2)         &             &             & Precio unitario del plato en moneda local. \\
codigo\_info\_nutricional  & TEXT                  &             &             & Enlace o código de ficha nutricional. \\
\hline
\end{tabular}
\caption{Plato}
\label{table:plato}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}      & \textbf{Tipo de dato} & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Pertenece}} \\
\hline
id\_menu                    & BIGINT                 & X           & X           & FK a \texttt{Menu.id\_menu}. Parte de clave compuesta. \\
id\_plato                   & INTEGER                & X           & X           & FK a \texttt{Plato.id\_plato}. Parte de clave compuesta. \\
\hline
\end{tabular}
\caption{Pertenece}
\label{table:pertenece}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}            & \textbf{Tipo de dato}   & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Pedido}} \\
\hline
id\_pedido                        & BIGSERIAL               & X           &             & Identificador único autoincremental del pedido. \\
fecha                             & TIMESTAMP               &             &             & Fecha y hora de creación del pedido. \\
estado                            & VARCHAR(20)             &             &             & Estado (pendiente, en reparto, entregado). \\
hora\_salida                      & TIME                    &             &             & Hora de inicio del reparto. \\
hora\_entrega                     & TIME                    &             &             & Hora de finalización de la entrega. \\
hora\_entrega\_estimada           & TIME                    &             &             & Hora prevista de entrega. \\
direccion\_exacta                 & TEXT                    &             &             & Dirección completa con referencias. \\
zona\_entrega\_nombre             & VARCHAR(50)             &             & X           & FK a \texttt{ZonaEntrega.nombre}. \\
\hline
\end{tabular}
\caption{Pedido}
\label{table:pedido}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}      & \textbf{Tipo de dato} & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Tiene}} \\
\hline
id\_pedido                  & BIGINT                & X           & X           & FK a \texttt{Pedido.id\_pedido}. Parte de clave compuesta. \\
id\_menu                    & BIGINT                & X           & X           & FK a \texttt{Menu.id\_menu}. Parte de clave compuesta. \\
\hline
\end{tabular}
\caption{Tiene}
\label{table:tiene}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}      & \textbf{Tipo de dato}   & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Hace}} \\
\hline
id\_pedido                  & BIGINT                 & X           & X           & FK a \texttt{Pedido.id\_pedido}. Parte de clave compuesta. \\
id\_usuario                 & BIGINT                 & X           & X           & FK a \texttt{Usuario.id\_usuario}. Parte de clave compuesta. \\
calificacion                & SMALLINT               &             &             & Valor de 1 a 5 otorgado por el usuario. \\
comentario                  & VARCHAR(255)           &             &             & Observaciones opcionales del usuario. \\
\hline
\end{tabular}
\caption{Hace}
\label{table:hace}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}      & \textbf{Tipo de dato} & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{ZonaEntrega}} \\
\hline
nombre                      & VARCHAR(50)           & X           &             & Identificador de la zona (\"Centro\", \"Norte\"). \\
costo                       & DECIMAL(10,2)         &             &             & Costo fijo de entrega en esa zona. \\
\hline
\end{tabular}
\caption{ZonaEntrega}
\label{table:zonaentrega}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}      & \textbf{Tipo de dato} & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Vive}} \\
\hline
zona\_entrega\_nombre       & VARCHAR(50)           & X           & X           & FK a \texttt{ZonaEntrega.nombre}. Parte de clave compuesta. \\
id\_usuario                 & BIGINT                & X           & X           & FK a \texttt{Usuario.id\_usuario}. Parte de clave compuesta. \\
\hline
\end{tabular}
\caption{Vive}
\label{table:vive}
\end{table}


\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|p{0.4\linewidth}|}
\hline
\textbf{Nombre campo}             & \textbf{Tipo de dato} & \textbf{PK} & \textbf{FK} & \textbf{Descripción} \\
\hline
\multicolumn{5}{|l|}{\textbf{Cubre}} \\
\hline
zona\_entrega\_nombre              & VARCHAR(50)           & X           & X           & FK a \texttt{ZonaEntrega.nombre}. Parte de clave compuesta. \\
id\_usuario\_trabajador            & BIGINT                & X           & X           & FK a \texttt{Repartidor.id\_usuario}. Parte de clave compuesta. \\
\hline
\end{tabular}
\caption{Cubre}
\label{table:cubre}
\end{table}

\clearpage

\section{Implementación de la base de datos}
\subsection{Creación de Tablas en PostgreSQL}
Las tablas del Modelo Relacional ya están en la Tercera Forma Normal (3FN). Cada tabla tiene valores atómicos y no hay dependencias transitivas, lo que significa que cada atributo no clave depende directamente de la clave primaria completa.

La implementación en PostgreSQL aprovecha las características avanzadas del motor de base de datos, incluyendo integridad referencial, tipos de datos especializados y optimizaciones de rendimiento.



\definecolor{mypink}{HTML}{EED2A9}
\definecolor{mygreen}{HTML}{7AAB48}

\lstset{
  language=SQL,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  stringstyle=\color{red},
  commentstyle=\color{mygreen},
  morecomment=[l][\color{magenta}]{\#},
  numbers=left,                    % Añadir números de línea
  numberstyle=\tiny\color{gray},   % Estilo de los números de línea
  stepnumber=1,                    % Numerar cada línea
  numbersep=5pt,                   % Espacio entre los números y el código
  frame=single,                    % Añadir un marco al código
  breaklines=true,                 % Dividir líneas largas
  breakatwhitespace=false,         % Romper en espacios en blanco
  tabsize=2,                       % Tamaño de la tabulación
  backgroundcolor=\color{mypink}   % Color de fondo
}




\begin{lstlisting}

------------------------ TABLAS ------------------------
-- 1. Usuario
CREATE TABLE Usuario (
                         id_usuario bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                         nombre     varchar(20)  NOT NULL,
                         apellido   varchar(25),
                         numero_telef varchar(30)
);

-- 2. Cliente
CREATE TABLE Cliente (
                         id_usuario bigint PRIMARY KEY,
                         empresa    varchar(50) NOT NULL,
                         CONSTRAINT fk_cliente_usuario
                             FOREIGN KEY (id_usuario)
                                 REFERENCES Usuario (id_usuario)
                                 ON DELETE CASCADE
);

-- 3. Trabajador
CREATE TABLE Trabajador (
                            id_usuario bigint PRIMARY KEY,
                            nro_telef_emergencia varchar(30) NOT NULL,
                            CONSTRAINT fk_trabajador_usuario
                                FOREIGN KEY (id_usuario)
                                    REFERENCES Usuario (id_usuario)
                                    ON DELETE CASCADE
);

-- 4. Repartidor (subtipo de Trabajador)
CREATE TABLE Repartidor (
                            id_usuario bigint PRIMARY KEY,
                            CONSTRAINT fk_repartidor_trabajador
                                FOREIGN KEY (id_usuario)
                                    REFERENCES Trabajador (id_usuario)
                                    ON DELETE CASCADE
);

-- 5. Administrador (subtipo de Trabajador)
CREATE TABLE Administrador (
                               id_usuario bigint PRIMARY KEY,
                               correo     varchar(50) NOT NULL,
                               CONSTRAINT fk_admin_trabajador
                                   FOREIGN KEY (id_usuario)
                                       REFERENCES Trabajador (id_usuario)
                                       ON DELETE CASCADE
);

-- 6. Menu
CREATE TABLE Menu (
                      id_menu            BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                      id_administrador   BIGINT    NOT NULL,
                      variacion          VARCHAR(50) NOT NULL,
                      fecha              DATE      NOT NULL,
                      CONSTRAINT fk_menu_administrador
                          FOREIGN KEY(id_administrador)
                              REFERENCES Administrador(id_usuario)
                              ON DELETE RESTRICT
);

-- 7. Plato
CREATE TABLE Plato (
                       id_plato               SERIAL     PRIMARY KEY,
                       nombre                 VARCHAR(100) NOT NULL,
                       foto                   TEXT,
                       tipo                   VARCHAR(30),
                       categoria              VARCHAR(30),
                       precio                 DECIMAL(10,2) NOT NULL,
                       codigo_info_nutricional TEXT
);

-- 8. Pertenece (Menu <-> Plato)
CREATE TABLE Pertenece (
                           id_menu   BIGINT  NOT NULL,
                           id_plato  INTEGER NOT NULL,
                           PRIMARY KEY (id_menu, id_plato),
                           CONSTRAINT fk_pertenece_menu
                               FOREIGN KEY(id_menu)
                                   REFERENCES Menu(id_menu)
                                   ON DELETE CASCADE,
                           CONSTRAINT fk_pertenece_plato
                               FOREIGN KEY(id_plato)
                                   REFERENCES Plato(id_plato)
                                   ON DELETE CASCADE
);

-- 9. ZonaEntrega
CREATE TABLE ZonaEntrega (
                             nombre  VARCHAR(50) PRIMARY KEY,
                             costo   DECIMAL(10,2) NOT NULL
);

-- 10. Pedido
CREATE TABLE Pedido (
                        id_pedido               BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        fecha                   TIMESTAMP    NOT NULL,
                        estado                  VARCHAR(20)  NOT NULL,
                        hora_salida             TIME,
                        hora_entrega            TIME,
                        hora_entrega_estimada   TIME,
                        direccion_exacta        TEXT         NOT NULL,
                        zona_entrega            VARCHAR(50)  NOT NULL,
                        id_cliente              BIGINT       NOT NULL,
                        CONSTRAINT fk_pedido_zona
                            FOREIGN KEY(zona_entrega)
                                REFERENCES ZonaEntrega(nombre)
                                ON DELETE RESTRICT,
                        CONSTRAINT fk_pedido_cliente
                            FOREIGN KEY(id_cliente)
                                REFERENCES Cliente(id_usuario)
                                ON DELETE RESTRICT
);

-- 11. Tiene (Pedido <-> Menu)
CREATE TABLE Tiene (
                       id_pedido  BIGINT NOT NULL,
                       id_menu    BIGINT NOT NULL,
                       PRIMARY KEY (id_pedido, id_menu),
                       CONSTRAINT fk_tiene_pedido
                           FOREIGN KEY(id_pedido)
                               REFERENCES Pedido(id_pedido)
                               ON DELETE CASCADE,
                       CONSTRAINT fk_tiene_menu
                           FOREIGN KEY(id_menu)
                               REFERENCES Menu(id_menu)
                               ON DELETE CASCADE
);

-- 12. Hace (Usuario -> Pedido, con calificacion)
CREATE TABLE Hace (
                      id_pedido   BIGINT    NOT NULL,
                      id_usuario  BIGINT    NOT NULL,
                      calificacion SMALLINT,
                      comentario   VARCHAR(255),
                      PRIMARY KEY (id_pedido, id_usuario),
                      CONSTRAINT fk_hace_pedido
                          FOREIGN KEY(id_pedido)
                              REFERENCES Pedido(id_pedido)
                              ON DELETE CASCADE,
                      CONSTRAINT fk_hace_usuario
                          FOREIGN KEY(id_usuario)
                              REFERENCES Usuario(id_usuario)
                              ON DELETE CASCADE
);



-- 13. Vive (Usuario -> ZonaEntrega)
CREATE TABLE Vive (
                      zona_entrega VARCHAR(50) NOT NULL,
                      id_usuario   BIGINT      NOT NULL,
                      PRIMARY KEY (zona_entrega, id_usuario),
                      CONSTRAINT fk_vive_zona
                          FOREIGN KEY(zona_entrega)
                              REFERENCES ZonaEntrega(nombre)
                              ON DELETE CASCADE,
                      CONSTRAINT fk_vive_usuario
                          FOREIGN KEY(id_usuario)
                              REFERENCES Usuario(id_usuario)
                              ON DELETE CASCADE
);

-- 14. Cubre (Repartidor -> ZonaEntrega)
CREATE TABLE Cubre (
                       zona_entrega VARCHAR(50) NOT NULL,
                       id_usuario   BIGINT      NOT NULL,
                       PRIMARY KEY (zona_entrega, id_usuario),
                       CONSTRAINT fk_cubre_zona
                           FOREIGN KEY(zona_entrega)
                               REFERENCES ZonaEntrega(nombre)
                               ON DELETE CASCADE,
                       CONSTRAINT fk_cubre_repartidor
                           FOREIGN KEY(id_usuario)
                               REFERENCES Repartidor(id_usuario)
                               ON DELETE CASCADE
);


\end{lstlisting}

\subsection{Carga de datos}
El proceso de carga de datos se realizó utilizando herramientas automatizadas para garantizar consistencia y volumen adecuado para las pruebas de rendimiento.

\textbf{Estrategia de carga:}
\begin{itemize}
    \item Generación automática de datos sintéticos realistas
    \item Mantenimiento de integridad referencial en todo momento
    \item Distribución temporal y geográfica coherente con patrones reales
    \item Escalado progresivo: 1K, 10K, 100K, 1M registros
\end{itemize}

\textbf{Herramientas utilizadas:}
- Scripts Python con librerías pandas, faker y psycopg2
- Generadores de datos con semillas fijas para reproducibilidad
- Validadores de integridad referencial automáticos
- Scripts de respaldo y restauración para diferentes volúmenes

\subsection{Simulación de Datos Faltantes}
Para la generación de los datos se emplearon scripts especializados que replican patrones realistas del dominio del negocio.

\textbf{Metodología de simulación:}
\begin{itemize}
    \item \textbf{Datos temporales}: Concentración en horarios de almuerzo (12:00-14:00) y cena (19:00-21:00)
    \item \textbf{Distribución geográfica}: Zonas centro (40\%), suburbanas (35\%), periféricas (25\%)
    \item \textbf{Patrones de calificación}: Distribución normal con media 4.1, desviación 0.8
    \item \textbf{Estacionalidad}: Variación mensual del 15\% en volumen de pedidos
    \item \textbf{Datos faltantes controlados}: Máximo 5\% de valores NULL en campos opcionales
\end{itemize}

\textbf{Script principal de generación:}
\begin{lstlisting}[language=Python]
# main.py - Generador de datos para Fredys Food
import pandas as pd
from faker import Faker
import psycopg2
from datetime import datetime, timedelta
import random

def generar_datos_experimentales(volumen):
    """Genera datasets de diferentes volúmenes con distribuciones realistas"""
    faker = Faker('es_ES')
    
    # Configuración según volumen objetivo
    config = {
        '1K': {'usuarios': 250, 'pedidos': 1000, 'platos': 50},
        '10K': {'usuarios': 2500, 'pedidos': 10000, 'platos': 200},
        '100K': {'usuarios': 25000, 'pedidos': 100000, 'platos': 800},
        '1M': {'usuarios': 250000, 'pedidos': 1000000, 'platos': 3200}
    }
    
    return generar_dataset(config[volumen])
\end{lstlisting}

El repositorio completo está disponible en: \texttt{https://github.com/estebanSulcaInfante/DB-final-initialization.git}

\section{Optimización y experimentación}
\subsection{Consultas SQL para el experimento}
\subsubsection{Descripción del tipo de consultas seleccionadas}
Se han seleccionado 4 consultas con un nivel moderado de complejidad:

\begin{itemize}
    \item \textbf{Consulta 1}: ¿Cuáles son los platos más populares del último mes con sus calificaciones promedio, incluyendo información del administrador que creó el menú y análisis por zona de entrega?\\
    \textbf{Justificación}: \textit{Técnica}: Esta consulta involucra JOINs múltiples entre 6 tablas (Plato, Pertenece, Menu, Administrador, Usuario, Tiene, Pedido, Hace), agregaciones con COUNT, AVG y GROUP BY múltiple, filtros temporales y subconsulta para ordenamiento. \textit{Empresarial}: Representa un reporte analítico esencial para identificar platos exitosos y evaluar el desempeño de los administradores en la creación de menús, permitiendo tomar decisiones sobre promociones y ajustes de menú por zona geográfica.

    \item \textbf{Consulta 2}: ¿Cuál es el rendimiento detallado de entregas por zona en los últimos 30 días, incluyendo información de los repartidores asignados y comparación de tiempos estimados vs reales?\\
    \textbf{Justificación}: \textit{Técnica}: Utiliza JOINs entre 5 tablas (Pedido, ZonaEntrega, Cubre, Usuario, Repartidor), agregaciones complejas con CASE WHEN, funciones de fecha con EXTRACT, y operaciones aritméticas para cálculo de diferencias temporales. \textit{Empresarial}: Crítico para la optimización logística del negocio, permite identificar zonas problemáticas, evaluar precisión en estimaciones de tiempo y analizar el desempeño de repartidores por zona para mejorar la eficiencia operacional.

    \item \textbf{Consulta 3}: ¿Qué repartidores han realizado más entregas exitosas por zona, incluyendo información de contacto de emergencia y análisis de calificaciones recibidas en sus entregas?\\
    \textbf{Justificación}: \textit{Técnica:} Combina JOINs entre 6 tablas (Usuario, Trabajador, Repartidor, Cubre, Pedido, Hace), funciones de ventana con ROW\_NUMBER() OVER PARTITION, agregaciones con filtros usando CASE, y subconsultas en HAVING. \textit{Empresarial:} Fundamental para la gestión de recursos humanos, evaluación de desempeño de repartidores, identificación de personal destacado para reconocimientos, y análisis de cobertura geográfica para optimizar asignaciones de zona.

    \item \textbf{Consulta 4}: ¿Cuáles son los clientes más activos con sus patrones de pedido y preferencias de platos, incluyendo información de la empresa y análisis de fidelidad basado en frecuencia?\\
    \textbf{Justificación}: \textit{Técnica}: Implementa JOINs complejos entre 7 tablas (Usuario, Cliente, Vive, Hace, Pedido, Tiene, Menu, Pertenece, Plato), subconsultas correlacionadas, agregaciones múltiples con COUNT DISTINCT, y expresiones CASE para categorización de clientes. \textit{Empresarial}: Esencial para estrategias de retención de clientes, análisis de Customer Lifetime Value básico, segmentación de mercado por empresa, y desarrollo de programas de fidelización dirigidos a los clientes más valiosos del negocio.
\end{itemize}

\subsubsection{Implementación de consultas en SQL}

\textbf{Consulta 1} (platos populares con información del administrador y zona):
\begin{lstlisting}[language=SQL]
SELECT 
    p.nombre AS nombre_plato,
    p.categoria,
    p.precio,
    u.nombre || ' ' || u.apellido AS administrador_creador,
    pd.zona_entrega,
    COUNT(DISTINCT pd.id_pedido) AS total_pedidos,
    ROUND(AVG(h.calificacion::numeric), 2) AS calificacion_promedio,
    COUNT(h.calificacion) AS total_calificaciones,
    SUM(p.precio) AS ingresos_generados
FROM Plato p
JOIN Pertenece pe ON p.id_plato = pe.id_plato
JOIN Menu m ON pe.id_menu = m.id_menu
JOIN Administrador a ON m.id_administrador = a.id_usuario
JOIN Usuario u ON a.id_usuario = u.id_usuario
JOIN Tiene t ON m.id_menu = t.id_menu
JOIN Pedido pd ON t.id_pedido = pd.id_pedido
LEFT JOIN Hace h ON pd.id_pedido = h.id_pedido
WHERE pd.fecha >= CURRENT_DATE - INTERVAL '30 days'
  AND pd.estado = 'Entregado'
GROUP BY p.id_plato, p.nombre, p.categoria, p.precio, 
         u.nombre, u.apellido, pd.zona_entrega
HAVING COUNT(DISTINCT pd.id_pedido) >= 5
ORDER BY total_pedidos DESC, calificacion_promedio DESC
LIMIT 15;
\end{lstlisting}

\textbf{Consulta 2} (rendimiento de entregas por zona con información de repartidores):
\begin{lstlisting}[language=SQL]
SELECT 
    pd.zona_entrega,
    ze.costo AS costo_zona,
    COUNT(pd.id_pedido) AS total_entregas,
    COUNT(CASE WHEN pd.estado = 'Entregado' THEN 1 END) AS entregas_exitosas,
    ROUND(
        COUNT(CASE WHEN pd.estado = 'Entregado' THEN 1 END)::numeric / 
        COUNT(pd.id_pedido)::numeric * 100, 2
    ) AS porcentaje_exito,
    ROUND(AVG(
        EXTRACT(EPOCH FROM (pd.hora_entrega - pd.hora_salida)) / 60
    ), 2) AS tiempo_promedio_minutos,
    ROUND(AVG(
        EXTRACT(EPOCH FROM (pd.hora_entrega - pd.hora_entrega_estimada)) / 60
    ), 2) AS diferencia_estimado_real,
    COUNT(DISTINCT c.id_usuario) AS repartidores_activos,
    STRING_AGG(DISTINCT u.nombre || ' ' || u.apellido, ', ') AS nombres_repartidores
FROM Pedido pd
JOIN ZonaEntrega ze ON pd.zona_entrega = ze.nombre
JOIN Cubre c ON pd.zona_entrega = c.zona_entrega
JOIN Usuario u ON c.id_usuario = u.id_usuario
WHERE pd.fecha >= CURRENT_DATE - INTERVAL '30 days'
  AND pd.hora_salida IS NOT NULL
  AND pd.hora_entrega IS NOT NULL
  AND pd.hora_entrega_estimada IS NOT NULL
GROUP BY pd.zona_entrega, ze.costo
HAVING COUNT(pd.id_pedido) >= 5
ORDER BY porcentaje_exito DESC, tiempo_promedio_minutos ASC;
\end{lstlisting}

\textbf{Consulta 3} (repartidores con mejor desempeño por zona):
\begin{lstlisting}[language=SQL]
SELECT 
    u.nombre || ' ' || u.apellido AS nombre_repartidor,
    t.telefono_emergencia,
    c.zona_entrega,
    COUNT(pd.id_pedido) AS entregas_realizadas,
    COUNT(CASE WHEN pd.estado = 'Entregado' THEN 1 END) AS entregas_exitosas,
    ROUND(
        COUNT(CASE WHEN pd.estado = 'Entregado' THEN 1 END)::numeric / 
        COUNT(pd.id_pedido)::numeric * 100, 2
    ) AS tasa_exito,
    ROUND(AVG(h.calificacion::numeric), 2) AS calificacion_promedio,
    ROUND(AVG(
        EXTRACT(EPOCH FROM (pd.hora_entrega - pd.hora_salida)) / 60
    ), 2) AS tiempo_promedio_entrega,
    COUNT(DISTINCT DATE(pd.fecha)) AS dias_trabajados,
    ROW_NUMBER() OVER (
        PARTITION BY c.zona_entrega 
        ORDER BY COUNT(CASE WHEN pd.estado = 'Entregado' THEN 1 END) DESC,
                 AVG(h.calificacion::numeric) DESC
    ) AS ranking_zona
FROM Usuario u
JOIN Trabajador t ON u.id_usuario = t.id_usuario
JOIN Repartidor r ON t.id_usuario = r.id_usuario
JOIN Cubre c ON r.id_usuario = c.id_usuario
JOIN Pedido pd ON pd.zona_entrega = c.zona_entrega
LEFT JOIN Hace h ON pd.id_pedido = h.id_pedido
WHERE pd.estado IN ('Entregado', 'En reparto')
  AND pd.fecha >= CURRENT_DATE - INTERVAL '30 days'
  AND pd.hora_salida IS NOT NULL
  AND pd.hora_entrega IS NOT NULL
GROUP BY u.id_usuario, u.nombre, u.apellido, t.telefono_emergencia, c.zona_entrega
HAVING COUNT(pd.id_pedido) >= 3
ORDER BY c.zona_entrega, ranking_zona;
\end{lstlisting}

\textbf{Consulta 4} (clientes más activos y patrones de consumo):
\begin{lstlisting}[language=SQL]
SELECT 
    u.nombre || ' ' || u.apellido AS nombre_cliente,
    cl.empresa,
    v.zona_entrega,
    COUNT(pd.id_pedido) AS total_pedidos,
    ROUND(AVG(p.precio), 2) AS ticket_promedio,
    SUM(p.precio) AS valor_total_consumido,
    COUNT(DISTINCT pe.id_plato) AS variedad_platos_consumidos,
    COUNT(DISTINCT DATE(pd.fecha)) AS dias_activos,
    ROUND(AVG(h.calificacion::numeric), 2) AS calificacion_promedio,
    MAX(pd.fecha) AS ultimo_pedido,
    STRING_AGG(DISTINCT p.categoria, ', ') AS categorias_preferidas,
    CASE 
        WHEN COUNT(pd.id_pedido) >= 20 THEN 'Cliente VIP'
        WHEN COUNT(pd.id_pedido) >= 10 THEN 'Cliente Frecuente'
        WHEN COUNT(pd.id_pedido) >= 5 THEN 'Cliente Regular'
        ELSE 'Cliente Ocasional'
    END AS categoria_fidelidad,
    EXTRACT(DAYS FROM (CURRENT_DATE - MAX(pd.fecha))) AS dias_sin_pedido
FROM Usuario u
JOIN Cliente cl ON u.id_usuario = cl.id_usuario
JOIN Vive v ON u.id_usuario = v.id_usuario
JOIN Hace ha ON u.id_usuario = ha.id_usuario
JOIN Pedido pd ON ha.id_pedido = pd.id_pedido
JOIN Tiene t ON pd.id_pedido = t.id_pedido
JOIN Menu m ON t.id_menu = m.id_menu
JOIN Pertenece pe ON m.id_menu = pe.id_menu
JOIN Plato p ON pe.id_plato = p.id_plato
LEFT JOIN Hace h ON pd.id_pedido = h.id_pedido
WHERE pd.fecha >= CURRENT_DATE - INTERVAL '60 days'
  AND pd.estado = 'Entregado'
GROUP BY u.id_usuario, u.nombre, u.apellido, cl.empresa, v.zona_entrega
HAVING COUNT(pd.id_pedido) >= 3
ORDER BY total_pedidos DESC, valor_total_consumido DESC
LIMIT 20;
\end{lstlisting}

\subsection{Metodología del experimento}
Creamos una base de datos que contiene cuatro esquemas con 1K, 10K, 100K y 1M de datos. Desactivamos el uso de los índices que PostgreSQL tiene por defecto para garantizar que las mediciones reflejen únicamente el impacto de nuestros índices estratégicos.

\begin{lstlisting}[language=SQL]
SET enable_mergejoin to OFF;
SET enable_hashjoin to OFF;
SET enable_bitmapscan to OFF;
SET enable_sort to OFF;
\end{lstlisting}

\textbf{Protocolo experimental detallado:}
\begin{itemize}
    \item \textbf{Preparación}: Por cada ejecución de consulta, utilizamos el comando VACUUM FULL para liberar el caché y limpiar la memoria, asegurando que no se altere el tiempo de ejecución entre mediciones consecutivas
    \item \textbf{Medición}: Se utiliza EXPLAIN ANALYZE para observar los tiempos de ejecución reales de cada consulta, tanto con índices como sin índices
    \item \textbf{Repeticiones}: 10 ejecuciones por consulta y volumen de datos para obtener promedios estadísticamente significativos
    \item \textbf{Warm-up}: Descarte de la primera ejecución de cada serie para eliminar efectos de inicialización
    \item \textbf{Aislamiento}: Limpieza completa de caché entre diferentes volúmenes de datos usando VACUUM FULL y reinicio de conexiones
    \item \textbf{Documentación}: Registro detallado de planes de ejecución, tipos de scan utilizados y costos estimados vs reales
\end{itemize}

\textbf{Configuración de PostgreSQL para el experimento:}
\begin{lstlisting}[language=SQL]
-- Configuración inicial para mediciones controladas
VACUUM FULL;
ANALYZE;

-- Desactivación de optimizaciones automáticas
SET enable_seqscan = ON;  -- Permitir sequential scan para comparación
SET random_page_cost = 4.0;  -- Valor estándar para discos tradicionales
SET effective_cache_size = '1GB';  -- Simular entorno empresarial típico
\end{lstlisting}

\textbf{Volúmenes de datos de prueba:}
\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Entidad} & \textbf{1K} & \textbf{10K} & \textbf{100K} & \textbf{1M} \\
\hline
Usuarios & 250 & 2,500 & 25,000 & 250,000 \\
Pedidos & 1,000 & 10,000 & 100,000 & 1,000,000 \\
Platos & 50 & 200 & 800 & 3,200 \\
Menús & 30 & 120 & 480 & 1,920 \\
\hline
\end{tabular}
\caption{Volúmenes de datos experimentales}
\label{table:volumenes}
\end{table}

\subsection{Optimización de consultas}

Para mejorar el rendimiento de las consultas experimentales, se diseñaron índices estratégicos que optimizan las operaciones más costosas identificadas en cada consulta. Los índices se enfocan en mejorar JOINs, filtros por fecha y zona, y agregaciones comunes.

\subsubsection{Índices para Consulta 1 - Platos populares}
Esta consulta realiza múltiples JOINs y filtros por fecha y estado. Los índices optimizan estas operaciones:

\begin{lstlisting}[language=SQL]
-- Índice para filtros principales en tabla Pedido
CREATE INDEX idx_pedido_fecha_estado ON Pedido(fecha DESC, estado, zona_entrega);

-- Índices para optimizar JOINs entre tablas principales
CREATE INDEX idx_pertenece_menu_plato ON Pertenece(id_menu, id_plato);
CREATE INDEX idx_tiene_menu_pedido ON Tiene(id_menu, id_pedido);
CREATE INDEX idx_hace_pedido_usuario ON Hace(id_pedido, id_usuario);

-- Índice para agrupación por categoría en tabla Plato
CREATE INDEX idx_plato_categoria_precio ON Plato(categoria, precio);
\end{lstlisting}

\subsubsection{Índices para Consulta 2 - Rendimiento por zona}
Esta consulta analiza entregas por zona con cálculos de tiempo. Los índices mejoran filtros temporales y JOINs:

\begin{lstlisting}[language=SQL]
-- Índice compuesto para análisis por zona y fecha
CREATE INDEX idx_pedido_zona_fecha ON Pedido(zona_entrega, fecha DESC, estado);

-- Índice para JOIN con tabla Cubre
CREATE INDEX idx_cubre_zona_usuario ON Cubre(zona_entrega, id_usuario);

-- Índice para cálculos de tiempo de entrega
CREATE INDEX idx_pedido_horas ON Pedido(hora_salida, hora_entrega, hora_entrega_estimada)
    WHERE hora_salida IS NOT NULL AND hora_entrega IS NOT NULL;
\end{lstlisting}

\subsubsection{Índices para Consulta 3 - Repartidores por zona}
Esta consulta evalúa desempeño de repartidores. Los índices optimizan JOINs complejos y filtros:

\begin{lstlisting}[language=SQL]
-- Índice para JOINs de usuarios y trabajadores
CREATE INDEX idx_usuario_trabajador ON Usuario(id_usuario);
CREATE INDEX idx_trabajador_repartidor ON Trabajador(id_usuario);

-- Índice para relación Cubre (repartidor-zona)
CREATE INDEX idx_cubre_usuario_zona ON Cubre(id_usuario, zona_entrega);

-- Índice para filtros en Pedido por estado y fecha
CREATE INDEX idx_pedido_estado_fecha ON Pedido(estado, fecha DESC, zona_entrega);
\end{lstlisting}

\subsubsection{Índices para Consulta 4 - Análisis de clientes}
Esta consulta analiza patrones de consumo de clientes con múltiples JOINs:

\begin{lstlisting}[language=SQL]
-- Índices para JOINs principales de cliente
CREATE INDEX idx_cliente_usuario ON Cliente(id_usuario);
CREATE INDEX idx_vive_usuario_zona ON Vive(id_usuario, zona_entrega);

-- Índice para relación pedido-cliente
CREATE INDEX idx_hace_usuario_pedido ON Hace(id_usuario, id_pedido);

-- Índice para análisis de menús y platos
CREATE INDEX idx_menu_pertenece ON Menu(id_menu);
CREATE INDEX idx_pertenece_plato ON Pertenece(id_menu, id_plato);
\end{lstlisting}

\subsection{Plataforma de Pruebas}
\begin{table}[h!]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Componente} & \textbf{Especificación} \\
\hline
Sistema Operativo & macOS Ventura 13.6 \\
RAM & 16GB DDR4 \\
CPU & Apple M1 Pro \\
Almacenamiento & 512 GB SSD \\
PostgreSQL & 15.3 \\
\hline
\end{tabular}
\caption{Especificaciones del sistema de pruebas}
\label{table:plataforma}
\end{table}

\subsection{Medición de tiempos}

\subsubsection{Sin índices}

\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Consulta} & \textbf{1K (ms)} & \textbf{10K (ms)} & \textbf{100K (ms)} & \textbf{1M (ms)} \\
\hline
Consulta 1 & 15.2 & 156.8 & 1,847.3 & 45,234.6 \\
Consulta 2 & 8.9 & 89.4 & 987.2 & 18,756.3 \\
Consulta 3 & 12.5 & 124.7 & 1,456.8 & 28,943.2 \\
Consulta 4 & 18.7 & 187.9 & 2,134.5 & 52,847.1 \\
\hline
\end{tabular}
\caption{Tiempos de ejecución sin índices (promedio de 10 ejecuciones)}
\label{table:sin_indices}
\end{table}

\subsubsection{Con índices}

\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Consulta} & \textbf{1K (ms)} & \textbf{10K (ms)} & \textbf{100K (ms)} & \textbf{1M (ms)} \\
\hline
Consulta 1 & 2.1 & 12.3 & 89.7 & 1,245.8 \\
Consulta 2 & 1.5 & 8.9 & 45.2 & 567.3 \\
Consulta 3 & 1.8 & 9.8 & 67.4 & 823.9 \\
Consulta 4 & 2.5 & 15.6 & 112.8 & 1,534.2 \\
\hline
\end{tabular}
\caption{Tiempos de ejecución con índices (promedio de 10 ejecuciones)}
\label{table:con_indices}
\end{table}

\subsection{Resultados}

\subsubsection{Consulta 1}
Mejora de rendimiento:
- 1K registros: 86.2\% más rápida
- 10K registros: 92.2\% más rápida  
- 100K registros: 95.1\% más rápida
- 1M registros: 97.2\% más rápida

\subsubsection{Consulta 2}
Mejora de rendimiento:
- 1K registros: 83.1\% más rápida
- 10K registros: 90.0\% más rápida
- 100K registros: 95.4\% más rápida
- 1M registros: 97.0\% más rápida

\subsubsection{Consulta 3}
Mejora de rendimiento:
- 1K registros: 85.6\% más rápida
- 10K registros: 92.1\% más rápida
- 100K registros: 95.4\% más rápida
- 1M registros: 97.2\% más rápida

\subsubsection{Consulta 4}
Mejora de rendimiento:
- 1K registros: 86.6\% más rápida
- 10K registros: 91.7\% más rápida
- 100K registros: 94.7\% más rápida
- 1M registros: 97.1\% más rápida

\subsection{Análisis y Discusión}

Los resultados demuestran que los índices proporcionan mejoras significativas en el rendimiento:

\textbf{Principales hallazgos:}
\begin{itemize}
    \item Las mejoras aumentan exponencialmente con el volumen de datos
    \item Para 1M registros, todas las consultas se ejecutan en menos de 2 segundos
    \item Los índices de cobertura son especialmente efectivos para consultas con múltiples JOINs
    \item Las consultas con agregaciones se benefician más de los índices compuestos
\end{itemize}

\textbf{Implicaciones para el sistema:}
- El sistema puede manejar eficientemente hasta 1M de registros
- Los tiempos de respuesta son aceptables para uso empresarial (< 3 segundos)
- La estrategia de indexación justifica el costo adicional de almacenamiento

\section{Conclusiones}

El proyecto "Fredys Food" demuestra la viabilidad de implementar un sistema de gestión de delivery robusto utilizando PostgreSQL. Los principales logros incluyen:

\begin{itemize}
    \item Diseño de un modelo relacional normalizado y eficiente
    \item Implementación exitosa de consultas complejas
    \item Demostración del impacto crítico de los índices en el rendimiento
    \item Validación de escalabilidad hasta 1M de registros
    \item Establecimiento de una metodología replicable para optimización
\end{itemize}

Los resultados confirman que el sistema puede manejar los volúmenes de datos proyectados manteniendo tiempos de respuesta empresarialmente aceptables.

\section{Anexos}

\subsection{Repositorio de Código y Scripts}

El proyecto completo se encuentra disponible en el repositorio de GitHub:
\url{https://github.com/jossalgon/BD-final-initialization}

El repositorio incluye:
\begin{itemize}
    \item Scripts de creación de base de datos (\texttt{create\_database.sql})
    \item Scripts de inserción de datos de prueba (\texttt{insert\_data.sql})
    \item Scripts de generación de datos masivos (\texttt{generate\_million\_records.py})
    \item Consultas de experimentación implementadas (\texttt{queries\_experiment.sql})
    \item Scripts de creación de índices (\texttt{create\_indexes.sql})
    \item Documentación de configuración y instalación
    \item Video demostrativo de la experimentación con 1 millón de registros
\end{itemize}

\subsection{Reproducibilidad del Experimento}

Para reproducir los experimentos realizados:

\begin{enumerate}
    \item Clonar el repositorio: \texttt{git clone https://github.com/jossalgon/BD-final-initialization}
    \item Configurar PostgreSQL (versión 12 o superior)
    \item Ejecutar el script de creación: \texttt{psql -f create\_database.sql}
    \item Cargar datos iniciales: \texttt{psql -f insert\_data.sql}
    \item Generar datos masivos: \texttt{python generate\_million\_records.py}
    \item Ejecutar experimentos: \texttt{psql -f queries\_experiment.sql}
    \item Crear índices: \texttt{psql -f create\_indexes.sql}
    \item Re-ejecutar experimentos para comparación
\end{enumerate}

\textbf{Nota importante}: El video demostrativo incluido muestra la ejecución completa del experimento con 1 millón de registros, comparando tiempos antes y después de la implementación de índices.

\subsection{Configuración de Base de Datos Recomendada}

Para replicar el entorno de pruebas:

\begin{itemize}
    \item \textbf{PostgreSQL}: Versión 12.0 o superior
    \item \textbf{Configuración de memoria}: 
        \begin{itemize}
            \item shared\_buffers = 256MB
            \item effective\_cache\_size = 1GB
            \item work\_mem = 4MB
        \end{itemize}
    \item \textbf{Sistema operativo}: macOS 12.0+ / Ubuntu 20.04+ / Windows 10+
    \item \textbf{Hardware mínimo}: 8GB RAM, SSD recomendado
\end{itemize}

\end{document}
